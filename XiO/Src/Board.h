#pragma once
#include <functional>
#include "Utils/State.h"
#include "Utils/GameMode.h"

////////////////////////////////////////////////////////////
// Klasa odpowiedzialna za planszê.
////////////////////////////////////////////////////////////
class Board {
public:
	Board(int, GameMode, Difficulty = Difficulty::HARD);

	////////////////////////////////////////////////////////////
	// Zwraca wartoœæ planszy na pozycji `x`, `y`.
	////////////////////////////////////////////////////////////
	State getAt(int x, int y);

	////////////////////////////////////////////////////////////
	// Ustawia wartoœæ planszy na pozycji `x`, `y` jako `state`.
	////////////////////////////////////////////////////////////
	void setAt(int x, int y, State state);

	////////////////////////////////////////////////////////////
	// Zwraca rozmiar planszy. Dla planszy 3x3 zostanie 
	// zwrócona wartoœæ 3.
	////////////////////////////////////////////////////////////
	int getSize();

	////////////////////////////////////////////////////////////
	// Zwraca obecny tryb gry.
	////////////////////////////////////////////////////////////
	GameMode getGameMode();

	////////////////////////////////////////////////////////////
	// Zwraca `State::X` lub `State::O` w zale¿noœci od tego,
	// czyj ruch jest obecnie.
	////////////////////////////////////////////////////////////
	State getCurrentPlayer();

	////////////////////////////////////////////////////////////
	// Zwraca `true` jedynie, gdy gra zosta³a zakoñczona 
	// wygran¹ lub remisem.
	////////////////////////////////////////////////////////////
	bool isComplete();

	////////////////////////////////////////////////////////////
	// Wykonuje ruch w zale¿noœci od wybranego poziomu 
	// trudnoœci.
	////////////////////////////////////////////////////////////
	void makeMove();

	////////////////////////////////////////////////////////////
	// Pozwala ustawiæ funkcjê, która zostanie wywo³ana, gdy
	// gra zostanie zakoñczona.
	////////////////////////////////////////////////////////////
	void setOnCompleteListener(std::function<void(State)>);

	////////////////////////////////////////////////////////////
	// Pozwala zresetowaæ planszê.
	// Ustawia wszystkie pola na `State::NONE`.
	////////////////////////////////////////////////////////////
	void reset();

private:
	////////////////////////////////////////////////////////////
	// Sprawdza czy podana plansza jest kompletna. Je¿eli jest
	// remis zwracana wartoœæ to `State::TIE`, je¿eli wygra³
	// gracz z kólkiem to - `State::O`, natomaist dla gracza
	// z iksem - `State::X`.
	////////////////////////////////////////////////////////////
	State checkComplete(std::vector<State>);

	////////////////////////////////////////////////////////////
	// Wykonuje ruch na podstawie wylosowanej pozycji z 
	// dostêpnych.
	////////////////////////////////////////////////////////////
	void makeEasyMove();

	////////////////////////////////////////////////////////////
	// Je¿eli na planszy znajduje siê rz¹d danego gracza, to
	// algorytm go zablokuje albo wykona ruch, który pozwoli
	// mu wygraæ. Natomiast, gdy nie ma takiej mo¿liwoœci, 
	// wylosuje pozycjê z dostêpnych.
	////////////////////////////////////////////////////////////
	void makeMediumMove();

	////////////////////////////////////////////////////////////
	// Algorytm `minimax` do analizowania planszy i 
	// znaleznienia najlepszego ruchu.
	////////////////////////////////////////////////////////////
	void makeHardMove();

	////////////////////////////////////////////////////////////
	// Zwraca liczbê tych samych pól w rzêdzie dla rzêdu `y`.
	////////////////////////////////////////////////////////////
	int countHorizontally(std::vector<State>, int y, State, int&);

	////////////////////////////////////////////////////////////
	// Zwraca liczbê tych samych pól w kolumnie dla kolumny `x`.
	////////////////////////////////////////////////////////////
	int countVertically(std::vector<State>, int x, State, int&);

	////////////////////////////////////////////////////////////
	// Zwraca liczbê tych samych pól dla przek¹tnej.
	// Je¿eli `left` jest równe `true`, to sprawdzana bêdzie
	// przek¹tna z lewego górnego rogu.
	////////////////////////////////////////////////////////////
	int countDiagonally(std::vector<State>, bool left, State, int&);

	////////////////////////////////////////////////////////////
	// Algorytm rekurencyjny do znajdowania najbardziej 
	// op³acalnego miejsca na kolejny ruch.
	////////////////////////////////////////////////////////////
	int minimax(std::vector<State>, bool, int, int);

private:
	int size;
	GameMode gameMode;
	Difficulty difficulty;
	std::vector<State> map;
	State currentPlayer;

	bool complete;

	std::function<void(State)> onCompleteListener;
};